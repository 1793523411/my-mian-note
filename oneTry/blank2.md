# 正则表达式

## 字符匹配

横向匹配：`{m,n}`，表示连续出现最少 m 次，最多 n 次

纵向匹配：`[abc]`，表示该字符是可以字符“a”、“b”、“c”中的任何一个

`[123456abcdefGHIJKLM]`，可以写成`[1-6a-fG-M]`

匹配“a”、“-”、“z”这三者中任意一个字符:`[-az]`或`[az-]`或`[a\-z]`。即要么放在开头，要么放在结尾，要么转义

`[^abc]`，表示是一个除"a"、"b"、"c"之外的任意一个字符。字符组的第一位放^（脱字符），表示求反的概念

```js
\d就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。
\D就是[^0-9]。表示除数字外的任意字符。
\w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。
\W是[^0-9a-zA-Z_]。非单词字符。
\s是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。
\S是[^ \t\v\n\r\f]。 非空白符。.就是[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。
```

匹配任意字符:可以使用`[\d\D]`、`[\w\W]`、`[\s\S]`和`[^]`中任何的一个

量词

```js
{m,} 表示至少出现m次。
{m} 等价于{m,m}，表示出现m次。
? 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？
+ 等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。
* 等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。
```

贪婪匹配:`/\d{2,5}/`，表示数字连续出现 2 到 5 次。会匹配 2 位、3 位、4 位、5 位连续数字,但是其是贪婪的，它会尽可能多的匹配。你能给我 6 个，我就要 5 个。你能给我 3 个，我就 3 要个。反正只要在能力范围内，越多越好

惰性匹配:`/\d{2,5}?/`表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不在往下尝试了

多选分支:`(p1|p2|p3)`，其中 p1、p2 和 p3 是子模式，用|（管道符）分隔，表示其中任何之一,分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了

## 位置匹配

`^`（脱字符）匹配开头，在多行匹配中匹配行开头。

`$`（美元符号）匹配结尾，在多行匹配中匹配行结尾

`\b`是单词边界，具体就是`\w`和`\W`之间的位置，也包括`\w`和`^`之间的位置，也包括`\w`和`$`之间的位置

`\B`就是`\b`的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉`\b`，剩下的都是`\B`的

`(?=p)`，其中 p 是一个子模式，即 p 前面的位置

```js
var result = "hello".replace(/(?=l)/g, "#");
console.log(result);
// => "he#l#lo"
```

而`(?!p)`就是`(?=p)`的反面意思

```js
var result = "hello".replace(/(?!l)/g, "#");

console.log(result);
// => "#h#ell#o#"
```

`(?<=p)`

```js
var result = "hello".replace(/(?<=l)/g, "#");

console.log(result);
// => "hel#l#o"
```

`(?<!p)`

```js
var result = "hello".replace(/(?<!l)/g, "#");

console.log(result);
// => "#h#e#llo#"
```

## 括号的作用

分组:`/a+/`匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用`/(ab)+/`

分支结构：在多选分支结构(p1|p2)中，此处括号的作用也是不言而喻的，提供了子表达式的所有可能 `^I love (JavaScript|Regular Expression)$`

引用分组:格式是 yyyy-mm-dd,`/\d{4}-\d{2}-\d{2}/`,修改成括号版的:`/(\d{4})-(\d{2})-(\d{2})/`

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
console.log(string.match(regex));
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
```

match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本

也可以使用构造函数的全局属性$1 至$9 来获取

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";

regex.test(string); // 正则操作即可，例如
//regex.exec(string);
//string.match(regex);

console.log(RegExp.$1); // "2017"
console.log(RegExp.$2); // "06"
console.log(RegExp.$3); // "12"
```

想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, "$2/$3/$1");
console.log(result);
// => "06/12/2017"
```

其中 replace 中的，第二个参数里用$1、$2、$3 指代相应的分组。等价于如下的形式

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function () {
  return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;
});
console.log(result);
// => "06/12/2017"
```

也等价于：

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function (match, year, month, day) {
  return month + "/" + day + "/" + year;
});
console.log(result);
// => "06/12/2017"
```

反向引用:除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用

写一个正则支持匹配如下三种格式：

```
2016-06-12

2016/06/12

2016.06.12
```

最先可能想到的正则是:

```js
var regex = /\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}/;
var string1 = "2017-06-12";
var string2 = "2017/06/12";
var string3 = "2017.06.12";
var string4 = "2016-06/12";
console.log(regex.test(string1)); // true
console.log(regex.test(string2)); // true
console.log(regex.test(string3)); // true
console.log(regex.test(string4)); // true
```

其中/和.需要转义。虽然匹配了要求的情况，但也匹配"2016-06/12"这样的数据

假设我们想要求分割符前后一致怎么办？此时需要使用反向引用

```js
var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
var string1 = "2017-06-12";
var string2 = "2017/06/12";
var string3 = "2017.06.12";
var string4 = "2016-06/12";
console.log(regex.test(string1)); // true
console.log(regex.test(string2)); // true
console.log(regex.test(string3)); // true
console.log(regex.test(string4)); // false
```

\10 是表示第 10 个分组，还是\1 和 0 呢？

答案是前者，虽然一个正则里出现\10 比较罕见。测试如下：

```js
var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/;
var string = "123456789# ######";
console.log(regex.test(string));
// => true
```

引用不存在的分组会怎样？因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如\2，就匹配"\2"。注意"\2"表示对"2"进行了转意

非捕获分组,之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组,如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。此时可以使用非捕获分组(?:p)，例如

```js
var regex = /(?:ab)+/g;
var string = "ababa abbb ababab";
console.log(string.match(regex));
// => ["abab", "ab", "ababab"]
```

## 回溯法原理

没有回溯的匹配:`/ab{1,3}c/` ,`'abc'`

有回溯的匹配:`/ab{1,3}c/`,`"abbc"`

有回溯的匹配:`/ab{1,3}bbc/`,`"abbbc"`

常见的回溯形式:本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”

贪婪量词:`b{1,3}`，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试"bbb"，然后再看整个正则是否能匹配。不能匹配时，吐出一个"b"，即在"bb"的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了,虽然局部匹配是贪婪的，但也要满足整体能正确匹配

如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？答案是，先下手为强！因为深度优先搜索。测试如下：

```js
var string = "12345";
var regex = /(\d{1,3})(\d{1,3})/;
console.log(string.match(regex));
// => ["12345", "123", "45", index: 0, input: "12345"]
```

前面的\d{1,3}匹配的是"123"，后面的\d{1,3}匹配的是"45"

惰性量词:惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配

```js
var string = "12345";
var regex = /(\d{1,3}?)(\d{1,3})/;
console.log(string.match(regex));
// => ["1234", "1", "234", index: 0, input: "12345"]
```

虽然惰性量词不贪，但也会有回溯的现象。比如正则是：`/^\d{1,3}?\d{1,3}$/`,目标字符串是"12345",知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后\d{1,3}?匹配的字符是"12"，是两个数字，而不是一个

```js
var string = "12345";
var regex = /(^\d{1,3}?)(\d{1,3}$)/;
console.log(string.match(regex));
// => ["12345", "12", "345"]
```

分支结构:我们知道分支也是惰性的，比如`/can|candy/`，去匹配字符串"candy"，得到的结果是"can"，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。

```js
var string = "candy";
var regex = /^(?:can|candy)$/;
console.log(string.match(regex));
//["candy"]


